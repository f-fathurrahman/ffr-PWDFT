SUBROUTINE my_rotrflm(rot, lmax, n, ld, rflm1, rflm2)
! !INPUT/OUTPUT PARAMETERS:
!   rot   : rotation matrix (in,real(3,3))
!   lmax  : maximum angular momentum (in,integer)
!   n     : number of functions to rotate (in,integer)
!   ld    : leading dimension (in,integer)
!   rflm1 : coefficients of the real spherical harmonic expansion for each
!           function (in,real(ld,n))
!   rflm2 : coefficients of rotated functions (out,complex(ld,n))
! !DESCRIPTION:
!   Rotates a set of real functions
!   $$ f_i({\bf r})=\sum_{lm}f_{lm}^iR_{lm}(\hat{\bf r}) $$
!   for all $i$, given the coefficients $f_{lm}^i$ and a rotation matrix $R$.
!   This is done by first the computing the Euler angles $(\alpha,\beta,\gamma)$
!   of $R^{-1}$ (see routine {\tt roteuler}) and THEN  applying the spherical
!   harmonic rotation matrix generated by the routine {\tt rlmrot}.
  IMPLICIT NONE 
  ! arguments
  REAL(8), intent(in) :: rot(3,3)
  INTEGER, intent(in) :: lmax,n,ld
  REAL(8), intent(in) :: rflm1(ld,*)
  REAL(8), intent(out) :: rflm2(ld,*)
  ! local variables
  INTEGER l,lm,nm,p
  REAL(8) det,rotp(3,3)
  REAL(8) ang(3),angi(3)
  ! automatic arrays
  REAL(8) d(ld,ld)
  !
  write(*,*) 'in my_rotrflm: ld = ', ld
  !
  IF(lmax < 0) THEN 
    WRITE(*,*)
    WRITE(*,'("Error(rotrflm): lmax < 0 : ",I8)') lmax
    WRITE(*,*)
    stop
  ENDIF 
  IF(n == 0) RETURN 
  IF(n < 0) THEN 
    WRITE(*,*)
    WRITE(*,'("Error(rotrflm): n < 0 : ",I8)') n
    WRITE(*,*)
    stop
  ENDIF 
  ! find the determinant
  det=rot(1,2)*rot(2,3)*rot(3,1)-rot(1,3)*rot(2,2)*rot(3,1) &
     +rot(1,3)*rot(2,1)*rot(3,2)-rot(1,1)*rot(2,3)*rot(3,2) &
     +rot(1,1)*rot(2,2)*rot(3,3)-rot(1,2)*rot(2,1)*rot(3,3)
  ! make the rotation proper
  p = 1
  IF(det < 0.d0) p = -1
  rotp(:,:) = dble(p)*rot(:,:)
  ! compute the Euler angles of the rotation matrix
  CALL roteuler(rotp,ang)
  ! inverse rotation: the function is to be rotated, not the spherical harmonics
  angi(1) = -ang(3)
  angi(2) = -ang(2)
  angi(3) = -ang(1)
  ! determine the rotation matrix for real spherical harmonics
  CALL rlmrot(p, angi, lmax, ld, d)
  !write(*,*) d
  ! apply rotation matrix
  DO l=0,lmax
    nm = 2*l + 1
    lm = l**2 + 1
    CALL dgemm('N', 'N', nm, n, nm, 1.d0, d(lm,lm), ld, rflm1(lm,1), ld, 0.d0, rflm2(lm,1), ld)
  ENDDO 
  RETURN 
END SUBROUTINE 
